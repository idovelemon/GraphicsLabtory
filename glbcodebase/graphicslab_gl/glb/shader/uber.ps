//----------------------------------------------------
// Declaration: Copyright (c), by i_dovelemon, 2016. All right reserved.
// Author: i_dovelemon[1322600812@qq.com]
// Date: 2016 / 10 / 15
// Brief: This is a uber shader, all the light calculation, texture mapping
// and some sort of that will be implemented in this shader.
//----------------------------------------------------
// Input attributes
in vec3 vs_Vertex;

#ifdef GLB_COLOR_IN_VERTEX
in vec3 vs_Color;
#endif

#ifdef GLB_NORMAL_IN_VERTEX
in vec3 vs_Normal;
#endif

#ifdef GLB_TEXCOORD_IN_VERTEX
in vec2 vs_TexCoord;
#endif

// Output color
out vec4 oColor;

#ifdef GLB_TEXCOORD_IN_VERTEX
uniform sampler2D glb_DiffuseTex;

	#ifdef GLB_ENABLE_ALPHA_TEX
	uniform sampler2D glb_AlphaTex;
	#endif

#endif

#ifdef GLB_ENABLE_SHADOW
uniform sampler2D glb_ShadowTex;
uniform mat4 glb_ShadowM;
#endif

#ifdef GLB_ENABLE_AO
uniform float glb_ScreenWidth;
uniform float glb_ScreenHeight;
uniform sampler2D glb_AOMap;
#endif

#ifdef GLB_ENABLE_LIGHTING
uniform vec3 glb_Material_Ambient;
uniform vec3 glb_Material_Diffuse;
uniform vec3 glb_Material_Specular;
uniform vec3 glb_Material_Emission;
uniform float glb_Material_Pow;

uniform vec3 glb_EyePos;

	#ifdef GLB_USE_PARALLEL_LIGHT
	uniform vec3 glb_ParallelLight_Dir;
	uniform vec3 glb_ParallelLight_Ambient;
	uniform vec3 glb_ParallelLight_Diffuse;
	uniform vec3 glb_ParallelLight_Specular;

	vec3 calc_diffuse(vec3 light_vec, vec3 normal, vec3 diffuse, vec3 light_color) {
		float ratio = dot(light_vec, normal);
		ratio = max(ratio, 0.0);
		return diffuse * light_color * ratio;
	}

	vec3 calc_specular(vec3 light_vec, vec3 normal, vec3 view_vec, vec3 specular, vec3 light_color, float pow_value) {
		/*******************************************
		* reflect(incident light vector, surface normal)
		* incident_light_vec = -light_vec
		********************************************/
		vec3 ref_light_vec = reflect(-light_vec, normal);
		float ratio = dot(ref_light_vec, view_vec);
		ratio = max(ratio, 0.0);
		ratio = pow(ratio, pow_value);

		return specular * light_color * ratio;
	}
	#else
		#error No light source specified
	#endif

#endif  // GLB_ENABLE_LIGHTING

void main() {
	oColor = vec4(0.0, 0.0, 0.0, 1.0);

#ifdef GLB_TEXCOORD_IN_VERTEX
	oColor = texture2D(glb_DiffuseTex, vs_TexCoord);

	#ifdef GLB_ENABLE_ALPHA_TEX
		oColor.w = texture2D(glb_AlphaTex, vs_TexCoord).w;
	#endif
#endif

#ifdef GLB_COLOR_IN_VERTEX
	oColor.xyz = vec3(oColor.xyz + vs_Color);
#endif

	float is_in_shadow = 0.0;
#ifdef GLB_ENABLE_SHADOW
	vec4 light_space_pos = glb_ShadowM * vec4(vs_Vertex, 1.0);
	light_space_pos.xyz /= 2.0f;
	light_space_pos.xyz += 0.5f;
	light_space_pos.xyz /= light_space_pos.w;
	float factor = texture2D(glb_ShadowTex, light_space_pos.xy).z;
	if (factor < light_space_pos.z) {
		is_in_shadow = 1.0;
	}
#endif

#ifdef GLB_ENABLE_LIGHTING
	if (is_in_shadow <= 0.0) {
		vec3 view_vec = normalize(glb_EyePos - vs_Vertex);

		#ifdef GLB_NORMAL_IN_VERTEX
			vec3 normal = normalize(vs_Normal);
		#else
			#error No normal in vertex attributes
		#endif

		#ifdef GLB_USE_PARALLEL_LIGHT
			vec3 light_vec = -glb_ParallelLight_Dir;
			vec3 ambient = glb_Material_Ambient * glb_ParallelLight_Ambient;

			vec3 diffuse = calc_diffuse(light_vec, normal, glb_Material_Diffuse, glb_ParallelLight_Diffuse);
			vec3 specular = calc_specular(light_vec, normal, view_vec, glb_Material_Specular, glb_ParallelLight_Specular, glb_Material_Pow);
			vec3 light = ambient + diffuse + specular;		
		#endif

		#ifdef GLB_TEXCOORD_IN_VERTEX
			oColor.xyz = vec3(oColor.xyz * light + glb_Material_Emission);
		#else
			oColor.xyz = vec3(light + glb_Material_Emission);
		#endif
	} else {
		vec3 ambient = glb_Material_Ambient * glb_ParallelLight_Ambient;	

		#ifdef GLB_TEXCOORD_IN_VERTEX
			oColor.xyz = vec3(oColor.xyz * ambient + glb_Material_Emission);
		#else
			oColor.xyz = glb_Material_Emission + ambient;
		#endif
	}
#else
	if (is_in_shadow >= 1.0) {
		oColor.xyz = 0.5 * oColor.xyz;
	}
#endif

#ifdef GLB_ENABLE_AO
	vec2 ao_coord = vec2(gl_FragCoord.x / glb_ScreenWidth, gl_FragCoord.y / glb_ScreenHeight);
	oColor.xyz *= texture2D(glb_AOMap, ao_coord).rgb;
#endif	
}